Programming Language Syntax Doc - 1.1
_______________________________________________________________________________________________________________________

Requirements:  Matrix Syntax Specification
_______________________________________________________________________________________________________________________

Purpose - The purpose of this doc is to describe the syntax for matrices.

_______________________________________________________________________________________________________________________


Description:

  o There are the two formats for matrices: 

  	1. "Strict indention, No brackets required"
  		Used in standard matrix creation pages. The goal here is to have convenient syntax that looks nice. 
  		SO REMEMBER: The Brackets required syntax is the true syntax, the strict Indention syntax is just a CONVIENENCE SYNTAX!
  		
  		- Brackets not required, but can use them if you'd like.
  		
       	- Indentation for this format is strict
			All child descriptors must be indented one extra level from its parent. This is the format that will be used for manually created matrices (meaning, a matrix typed in by the user).
       		
       	- the '+' on the +`item name` operator for item names is optional
       		`item name` is actually a labeled descriptor with hidden Descriptor name: ITEM `item name`
       		And, for labeled Descriptors, the '+' is optional in the convenience format for matrices (what happens is the + is always added in).
       		
       		
       Probably, what the compiler will do is it will simply do a pass over the matrices and turn it from a no bracket matrix definition to one with brackets. The reason for the strict indentation is because the indentation indicates the child elements. Still up in the air how this will be done.
     
  	2. Brackets required, free indention 
	  	The reason for this format is it is context-free. A parser can identify whether something is a child descriptor of a parent simply through the body brackets. It's useful for matrices that are generated by scripts.
	  	
		- Item body brackets and descriptor body brackets required.
		- The descriptor field brackets are optional. 
     
       	- Indentation for this format is free
       		
       	- the '+' on the +`item name` operator for item names is required
     
		NOTE: hmm, actually, I think you can do indent tracking in a context free manner. You just have to have productions for each level of indentation, one for one tab character and a descriptor, another for two tab characters and a descriptor.... But, I'd like to be able to keep my grammar as clean and simple a possible.
  

  o DESCRIPTOR:  - the ':' symbol after the descriptor means child field values follow. 
  	Note, it does _not_ mean child _descriptor elements_ follow. 
  
	- So in brackets-required format, if there is no field values, but there are child descriptors, leave off the ':' and put brackets around the child descriptors
	
	In brackets-optional format, in the same situation, you do the same thing, but instead of bracketing, you indent the child descriptors. NOTE: you actually _can_ have the ':' in this format. The parser will put a pair of empty brackets were the field values should go. The reason you'd want to have it is because it looks better that way.
	
	- In brackets-required format, the descriptor body brackets are optional.
	
	
	
  o ITEMS and FIELDS are just specialized descriptors
  
  	They have the same syntax and work the same way. The way an item works is you have the label for the item, then you can follow it with child field-values if you put the "has childern operator", ':',  after it (typically you don't have any), then you have an open bracket, which is where you put the child descriptors.
  	
  	An Item and a field are both "hidden descriptor-name" descriptors:
  	
  	ITEM `Item Name`
  	Field `Field Name`
  	









____________________________________________________




//  Strict Indention, no Body Brackets
//  __________________________________
//  To end the descriptor, need to end line with no comma, and need new line
//  and to start next line with a 'colon-after' symbol.

//  NOTE: here, for strict indentation, by default, the item names have the option set to where `item name` is 
//  autoconverted to +`item name`

`First Name`
	FORM.REQUIRED:	:IS_REQUIRED, "*"    
	FORM.LABEL:		"First Name", "Enter you first name"       
	FORM.INPUT:		:TEXT, FIELD_MAXCHARS,        				
	DB.COLUMN:		:STRING, :TABLES.Person, :COL_TYPE.PRIMARY_KEY
	
`States`
	FORM.REQUIRED:	`Is Required`, "*" 
	FORM.LABEL:		"State", "Choose your state"
	
	FORM.SELECT:	"StateSelector" #name of html select tag#  
		SELECT_OPTIONS:							               	// Notice, here we have the ':' which means field values
			OPTION: "AL", "Alaska", :SELECTED					// follow, even-though none do. But it's okay because
			OPTION: "AZ", "Arizona"								// doesn't mess up the parser, and it looks better that
																// way.			
	DB.COLUMN:		:STRING, :TABLES.Person, :COL_TYPE.PRIMARY_KEY





















//  Required brackets and free indention. 
//  _____________________________________
//  The item and descriptor-child brackets are required.

//  NOTE 1: in required brackets format, the +`item name` operator is required (can't use just `item name`)
//  Notice, the field comment: 25#max chars# - not really happy about field comments operator. Is there a better one?

+`First Name` {
	FORM.REQUIRED: 	:IS_REQUIRED, "*"   
	FORM.LABEL:		FIRSTNAME_LABEL, "Enter your first name"
	FORM.INPUT:		:TEXT, FIELD_MAXCHARS #max chars#         				
	DB.COLUMN:		:STRING, :TABLES.Person, :COL_TYPE.PRIMARY_KEY 
}


+`States` {
	FORM.REQUIRED:	`Is Required`, "*"
	FORM.LABEL:		"State", "Choose your state"
	
	FORM.SELECT:	"StateSelector" #name of html select tag# {
		SELECT_OPTIONS  {
			OPTION:   { "AL", "Alaska", :SELECTED } // Notice, optional descriptor body brackets
			OPTION:  "AZ", "Arizona"
		}
	}
	DB.COLUMN:		 :STRING, :TABLES.Person
}






_______________________________________________________________________________________________________________________


Symbols, Constants, and Variables (and descriptor header) Syntax
________________________________________________________________	
	1. Symbols - use ":" in front of identifier
			   - also, the `symbol` syntax too.
			   
	2. Constants - are just java constants (identifiers). Often, the convention is they are all in cap
	3. Variables - mixed case identifiers

		

		

Descriptors
___________

	o Description:
		Descriptors are NOT symbols, they have a descriptor tag-name which is a symbol, and can have a label-name which is a symbol. A Descriptor is a part of data structure (The matrix data structure) (and maybe the only part, meaning you can make everything from descriptors. hmm...). And, Symbols are used to label descriptors so you can access them.
		
	o Accesing the descriptors of a Matrix.
		- When you access parts of a Matrix, you are "pulling" the descriptors out using their descriptor-tag names and/or their label-names (see Accessing Matrix Members doc)
		
	o Structure a Descriptor
		- A Descriptor has
			1. Descriptor Tag name
			2. Label-Name
			3. Field Values - a TUPLE with PRE-DEFINED TYPES (in schema) - see "Matrix Structure" and "Sets & Tuples" docs - BUT, descriptor field values are actually stored as an ORDERED SET!. Because, the way the tuple works is the schema is the mapping of value in the order set to its type!
			
			4. Child Descriptors - an ORDERED SET with DESCRIPTORS as items
			
			
		
	o There are a few behaviors for descriptors that can be set:
		1. Labels for descriptors
		2. Optional Descriptor Tag-Name - for descriptors where Label is required, can set tag-name to be optional
		3. Pass-through behavior
	
	
	
		1. Labeled Descriptors
		
			Descriptors can be labeled. this is useful when you have many child descriptors of the same type. This will let you uniquely identifier each child descriptor
			
			Here's an example from NDA (look at the NDA Spec for the full example)
			
				HAS `oi_std.xsl` IN `src\xsl`: OPEN_DEV
						^
						|
				*This is the label name given to the descriptor
				
			Parenthesis are optional:
				HAS (`oi_std.xsl` IN `src\xsl`): OPEN_DEV
				
				
			- Specification of Labels for Descriptors:
				
				o IN CONVIENCE MODE (the strict indentation mode): 
				  For labeled descriptors, can leave off the '+' for the symbol name creation. 
				  
				  It knows you _might_ be passing in a new symbol name (so, the '+' symbol operator will first try to find an existing symbol in that scope with the same name. if it doesn't find it, it will return a new symbol). But, remember, this is only in convience mode.
				
				
				o the label name of the descriptor for must be unique in the scope of all the childern at the same level
					NOTE: if the child is apart of a pass-through descriptor, must be unique at both levels, the current-level and it's parent's level, where it passes through to.
				
				o if the Label Name uses the IN operator then:
				
					1. The Full Name of the descriptor is just the first name plus the second name:
						`oi_std.xsl`.`src\xsl`  OR   
						`oi_std.xsl` IN `src\xsl`
						
						
					2. The full name must always be unique. 
						By default, short name does not have to be, but you can set it to be unique in the schema
					
					3. You can access the descriptor by both the full name or the first name.
						BUT, if you access it using its first name, and it is not unique, you must have a way to tell dev that when it isn't unique, like a non-unique "annotation" that it goes to (you know the -<1> stuff)
	
									
				o You can set a descriptor's Label-Settings in the schema.
				
				
					DESCRIPTOR SECTION.VIEW: PassThrough => :OPTIONAL, Label => ${ :OPTIONAL, :FirstName.IsUnique }
				
				
					- Here, a name may or may not be give to the descriptor. And, if you do, the first name must be unique (as well as the full name)
				
				
				
				o Multiple Package Names:
				
					*MAY ADD SUPPORT FOR MULTIPLE PACKGE NAMES:
						// ITEM
						`header for registration` IN ${ html.layout, registration.header };
				
					The reason this is useful is because it acts like a bunch of properties you can set on the item. but the reason this may not be useful is because you can probably just do the same thing with the item fieldset. hmm...
		
		
		2. Optional Descriptor Tag-Name - for descriptors where Label is required, can set tag-name to be optional
		
			- ITEMS and FIELDS are actually name descriptors with the descriptor tag-name as optional
					
				o The real syntax for defining ITEMS and FIELDS is:
				
					ITEM `First Name`:
						FORM.REQUIRED:	FIELD.Required => :IsRequired
										  ^
										  |
								* See, 'FIELD' is descriptor tag name, & 'Required' is the name of the descriptor
												
		
			- Specification for accessing Labeled Descriptors with Optional descriptor tag-name
				
				o If accessing members of a matrix, those members of a matrix with Labeled Descriptors can be accessed through the label name, without the Descriptors's tag-name
				
				
					Ex. ITEM and FIELD are Labeled Descriptors with hidden Descriptor Tag-Names, so you can access like:
					
						MyMatrix@:ITEM.`First Name`:FORM.REQUIRED:FIELD.IsRequired
						   OR
						MyMatrix@:`First Name`:FORM.REQUIRED:IsRequired 
						
						(  OR
						MyMatrix@[`First Name`]:FORM.REQUIRED...)
		
		
		
				o And, as mentioned above, can be accessed through short name or full name, as:
						`oi_std.xsl`.`src\xsl`  OR   
						`oi_std.xsl` IN `src\xsl`
						
						
						
						
		3. Pass-Through Descriptors
			- A pass-through descriptor is a descriptor whose child descriptors fall through and can also be directly accessed through the parent. An example from NDA would be the SECTION descriptors:
			
				COMPONENT `oi_std`:
					HAS `body_oi_std.jsp` IN `src\web\proddesc`
					
					[SECTION.VIEW:]
						HAS `oi_std.xsl` IN `src\xsl`: OPEN_DEV
					
					[SECTION.MODEL:]
						HAS `EntityLayerInfo` IN `com.rootlevel.Medium`
				
			
			- The syntax for pass-through descriptors is:  [<DESCRIPTOR_NAME>:]
				but, this is just a convenience syntax (I think, not sure at this point). It is converted to:
				
				DESCRIPTOR_NAME: PassThrough => :ON
			
			- You can set a descriptor's passthrough settings in the Schema. See the Schema Specificaiton for more details. 
		
	
	o SCHEMAS & DESCRIPTORS:
		- you define the schemas that a descriptor uses with a 'USES' clause:
		
			MATRIX.NEW myMatrix USES ( WEB.FORM, HTML ) { ... }
		
		- the ( ) are mandatory. Why? because if you use a schema name that is nested, it's ambiguous with fieldset.
			
			MATRIX.NEW myMatrix USES PARENT->CHILD   // PROBLEMS! - is CHILD apart of PARENT? or is it a field in 
													//  the fieldset
			o Why didn't I just use Set notation instead of parenthesis? 
			  because if i used Set notation: ... USES ${ MYSCHEMA }, then
			  to be completely consistent, I would have to allow single items, with no set notation, because any
			  place a set can be used, a var of the item type for the set can be used (as a set of one element):
			    ... USES MYSCHEMA, but which would lead back to the same problem with ambiguity with fieldsets
			  
			  
			  
													
		- note that the USES simply takes a SCHEMA SET constant. and, can take a SCHEMA constant too (no SET), becuase
		  it would just be a set of one.
		  
				final SET<SCHEMA> mySchemaSet = ${ SCHEMA1 };
					OR
				final SCHEMA mySingleSchema = SCHEMA2; // a single schema is a set of 1
		
		- note that a MATRIX is just a descriptor, which is why it uses the same syntax			

				
	o MULTI-DESCRIPTOR SETS
		-You can have a set of descriptors with the same child descriptors. For example,
		
			o Multiple Items with the same child set:
			  
				`First Name` { }
				
				${ `RptdByName1, `Reported By Name`} {
					FORM. REQUIRED ...
				}
				
				
			  *The ways this works is you have multiple names for the same item!
				
				
			o Multiple Descriptors: shared field set
				
				${ SECTION.VIEW, SECTION.DATA }: { Setting1 => myValue } {
					...
				}
		
			o Multiple Descriptors: separate field sets
				
				${ SECTION.VIEW: { Setting1 => value1 }, SECTION.DATA: { Setting1 => value2 } } {
					...
				}
		
			

FIELDS
______


	o Field Member assignment using field-value mapping
	
		- You can assign a values to a descriptor in two ways:
			1. The typical way which is by just listing the values in the correct order in the matrix fields
			
			2. or, you can map fields to their values. 
			   A typical example is in Matrix schemas, setting Pass Through Descriptors and named descriptors:
			   
			   SCHEMA NDA {  // This is an example from NDA

					// actually these are already defaults for both
					DESCRIPTOR SECTION.VIEW: { PassThrough => :OPTIONAL, Label => :OPTIONAL }; 
				
				 } 

	
				- Once you start to us one or the other, you must stick with it. You cannot mix and match (maybe, we'll allow this, but don't see a good reason to do so at this point).
		
		
		- Use field-value mappings in matrices where you're going to be setting just a few settings (not filling out all the fields). 
		
			o In this case, in the schema, know that the field name is typically going to be used when create a matrix using this field. So, the field value symbol-names should be short. 
		
			o NOTE: when you design schema fields where the field-value mapping is probably not going to be used, make field value symbol-names should be more descriptive
		
	
	o Field Tuples and Field Mapping Sets Syntax
		- in strict syntax, the field tuples and field mapping sets must be wrapped in brackets:
		
			DESCRIPTOR FORM.REQUIRED: {:IsRequired, "required.gif" }; 
			
			DESCRIPTOR SECTION.VIEW: { PassThrough => :OPTIONAL, Label => :OPTIONAL } {} 

		- and, if there is no descriptor body, the descriptor must end in a semi colon (see above example)
		
		- Also, in convenience format, the brackets around the fieldsets are optional!
		
	
	
	o Field-Value Mapping Sets-Variables
	
		- You can create set variables for field-value mappings. The reason is because you may be setting the same values on a bunch of the same descriptors, and don't want to type in all the same settins over and over again. (actually, $DITTO^... might work better in this case. Or maybe matrix templates where you set default values).
		
		the way you do it is by creating a set
		
			SET<KEY_VALUE_PAIRS> sectionSettings = ${ PassThrough => :OPTIONAL, Label => :OPTIONAL }; 

		And, you can use the set, descriptor Settings in your descriptors by using the ... operator
			
		SCHEMA NDA {
			DESCRIPTOR SECTION.VIEW: sectionSettings...
			
		}
		


Other Matrix syntax stuff
_________________________


	o Nested child block 
	
		if you want to specify a nested child block, use brackets:
	
			SELECT_OPTIONS {
				OPTION: "AL", "Alaska", SELECTED
				OPTION: "AZ", "Arizona"
			}
			
		And, if using Strict-Indention in your Matrix, can just indent in
		
			SELECT_OPTIONS:
				OPTION: "AL", "Alaska", SELECTED
				OPTION: "AZ", "Arizona"
			


	o Matrix Name
		- a Matrix name is a mix betweena descriptor tagname and a label name:
			
			MATRIX.NEW MyMatrix IN mypackage.stuff...
						^					^
						|					|
					like a descriptor		|
					tag name			like a label name in that it has an optional package
					
		
	o Matrix Members 
	
		- Matrix Descriptors can have child members, like int's, float's, strings...
		- And, since a Matrix itself is a descriptor, then it too can have child members.
		
			Example:
			
			MATRIX.NEW stuff USES blah {
			
				MEMBER int myint = 0;
				
				FORM.REQUIRED:  -... {
				
					MEMBER string mystring = "hi";
				}
			}

	o Descriptor with tuple that uses no braces and has no child descriptor body
		for this type of descriptor, you must end it with a semi colon. for example:
		
		FORM.REQUIRED:  :Is_Required;
		

