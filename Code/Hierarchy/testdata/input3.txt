/* This file was generated by SableCC (http://www.sablecc.org/). */

package net.unconventionalthinking.hierarchy.grammar.parser;

import net.unconventionalthinking.hierarchy.grammar.lexer.*;
import net.unconventionalthinking.hierarchy.grammar.node.*;
import net.unconventionalthinking.hierarchy.grammar.analysis.*;
import java.util.*;

import java.io.DataInputStream;
import java.io.BufferedInputStream;
import java.io.IOException;

@SuppressWarnings("nls")
public class Parser
{
    public final Analysis ignoredTokens = new AnalysisAdapter();

    protected ArrayList nodeList;

    private final Lexer lexer;
    private final ListIterator stack = new LinkedList().listIterator();
    private int last_pos;
    private int last_line;
    private Token last_token;
    private final TokenIndex converter = new TokenIndex();
    private final int[] action = new int[2];

    private final static int SHIFT = 0;
    private final static int REDUCE = 1;
    private final static int ACCEPT = 2;
    private final static int ERROR = 3;
    
    
    private MATRIX MyMatrix = MATRIX.NEW testMatrix USES (WEB.FORM) {
		`i 1` {
			T_8_1 USES (S1): { f1 => :RED, f2 => :RED.BLUE, f3.child => :"R e d", f4 => :"Red".blue, f5 => `r e d`, 
								f6 => `r e d`.`green`};
			T_8_2 USES (S1): { f1 => +:RED, f2 => +:RED.BLUE, f3 => var1.c1, f4 => :"Red".+:blue, f5 => `r e d`, 
									f6 => +`r e d`.`green`};
									
			TUPLE.TEST: { obj.methodcall(MyMatrix->`i 1`, :Symbol1), "2323", new Integer(23), ((2 + 3) * 5 * var1) };
		}
	};
	
    private DESCRIPTOR myDescriptor = DESCRIPTOR.NEW.USES<WEB.FORM> { FORM.REQUIRED: { :IsRequired }; };
    
    private int myInt_t1 = MyMatrix->some.value;
    private SET mySet = ${ 1, 2, :red};

	public DESCRIPTOR TestMethod(SET<int> s1, int i) {

    	int myInt_t2 = MyMatrix->some.value;
    	SET<DESCRIPTOR> mySet = MyMatrix->d1{*}->d2.${*};
    	SYMBOL s1 = :RED;
    	
    	DESCRIPTOR myDescriptor = DESCRIPTOR.NEW.USES<WEB.FORM> { FORM.REQUIRED: { :IsRequired }; };
    
    	
	}


    public Parser(@SuppressWarnings("hiding") Lexer lexer)
    {
        this.lexer = lexer;
    }

    protected void filter() throws ParserException, LexerException, IOException
    {
        // Empty body
    }

    private void push(int numstate, ArrayList listNode, boolean hidden) throws ParserException, LexerException, IOException
    {
        this.nodeList = listNode;

        if(!hidden)
        {
            filter();
        }

        if(!this.stack.hasNext())
        {
            this.stack.add(new State(numstate, this.nodeList));
            return;
        }

        State s = (State) this.stack.next();
        s.state = numstate;
        s.nodes = this.nodeList;
    }

    private int goTo(int index)
    {
        int state = state();
        int low = 1;
        int high = gotoTable[index].length - 1;
        int value = gotoTable[index][0][1];

        while(low <= high)
        {
            int middle = (low + high) / 2;

            if(state < gotoTable[index][middle][0])
            {
                high = middle - 1;
            }
            else if(state > gotoTable[index][middle][0])
            {
                low = middle + 1;
            }
            else
            {
                value = gotoTable[index][middle][1];
                break;
            }
        }

        return value;
    }

  

    @SuppressWarnings("unchecked")
    public Start parse() throws ParserException, LexerException, IOException
    {
        push(0, null, true);
        List<Node> ign = null;
        while(true)
        {
            while(index(this.lexer.peek()) == -1)
            {
                if(ign == null)
                {
                    ign = new LinkedList<Node>();
                }

                ign.add(this.lexer.next());
            }
		}
	}
}