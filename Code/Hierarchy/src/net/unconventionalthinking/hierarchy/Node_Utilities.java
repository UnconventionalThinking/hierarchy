/* Copyright 2012, 2013 Unconventional Thinking
 *
 * This file is part of Hierarchy.
 *
 * Hierarchy is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * Hierarchy is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with Hierarchy.  
 * If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * You need to put this in your own project src. The reason you need to add into your own project
 * is because these utilities need to access your sableCC node class, and your need to add the import systement
 * to your node package.
 * 1. Put this file in your SableCC project.
 * 2. Don't forget to rename the package!
 * 3. Also, add the import to your node package
 * 2. Replace the code generated in your Node.java file generated by sableCC with:

import net.unconventionalthinking.compiler.tools.*;

@SuppressWarnings("nls")
public abstract class Node extends AttributeNode implements Switchable, Cloneable

*/

package net.unconventionalthinking.hierarchy;


import net.unconventionalthinking.hierarchy.grammar.node.*;
import net.unconventionalthinking.compiler.tools.*;
import java.util.LinkedList;


public class Node_Utilities {


    public static void setCurrentAndParent_Code(Node currNode, CodeBuilder codeBuilder) {
       currNode.code(codeBuilder);
       currNode.parent().code(codeBuilder);
    }
    public static void setCurrentAndParent_Code(Node currNode, String code) {
       currNode.code(code);
       currNode.parent().code(currNode.code());
    }




    /**
     * Create a code string (actually, a codeBuilder string buffer) from the sableCC child nodes. The typical
     * useage for these class of methods are if you are creating a parameter list, and you want to separate each one by
     * a comma, then you can pass a ", " as the addBeforeTextString.
     * 
     * @param LinkedList <NodeType>     Make sure to pass in linkedList some sableCC node. Ex: LinkedList<AStart>
     * @return                          A CodeBuilder with all the child node code append together.
     */
    public static <NodeType> CodeBuilder createCode_fromManyChildNodes(LinkedList<NodeType> childNodes) {

        return createCode_fromManyChildNodes(null, childNodes, null);

    }
    /**
     * Create a code string (actually, a codeBuilder string buffer) from the sableCC child nodes. The typical
     * useage for these class of methods are if you are creating a parameter list, and you want to separate each one by
     * a comma, then you can pass a ", " as the addBeforeTextString.
     *
     * @param LinkedList <NodeType>     Make sure to pass in linkedList some sableCC node. Ex: LinkedList<AStart>
     * @param addBeforeTextString       The text string to add before each child's code string.
     * @return                          A CodeBuilder with all the child node code append together.
     */
    public static <NodeType> CodeBuilder createCode_fromManyChildNodes(String addBeforeTextString, LinkedList<NodeType> childNodes) {

        return createCode_fromManyChildNodes(addBeforeTextString, childNodes, null);

    }
    /**
     * Create a code string (actually, a codeBuilder string buffer) from the sableCC child nodes. The typical
     * useage for these class of methods are if you are creating a parameter list, and you want to separate each one by
     * a comma, then you can pass a ", " as the addBeforeTextString.
     *
     * @param LinkedList <NodeType>     Make sure to pass in linkedList some sableCC node. Ex: LinkedList<AStart>
     * @param addAfterTextString        The text string to add after each child's code string.
     * @return                          A CodeBuilder with all the child node code append together.
     */
    public static <NodeType> CodeBuilder createCode_fromManyChildNodes(LinkedList<NodeType> childNodes, String appendTextString) {

        return createCode_fromManyChildNodes(null, childNodes, appendTextString);

    }


    /**
     * Create a code string (actually, a codeBuilder string buffer) from the sableCC child nodes. The typical
     * useage for these class of methods are if you are creating a parameter list, and you want to separate each one by
     * a comma, then you can pass a ", " as the addBeforeTextString.
     *
     * @param LinkedList <NodeType>     Make sure to pass in linkedList some sableCC node. Ex: LinkedList<AStart>
     * @param addBeforeTextString       The text string to add before each child's code string.
     * @param addAfterTextString        The text string to add after each child's code string.
     * @return                          A CodeBuilder with all the child node code append together.
     */
    public static <NodeType> CodeBuilder createCode_fromManyChildNodes(String addBeforeTextString, LinkedList<NodeType> childNodes,
            String appendTextString) {
        
        if (childNodes == null || childNodes.isEmpty())
            return new CodeBuilder();


        // You pass in your linkedList<NodeType> with SableCC nodes derived from the SableCC node class.
        // But, what happens
        // is that in this method, we cast the list into a LinkedList<Node>. The reason is because
        // what we normally would do is have the user pass in a LinkedList<Node>, having to cast
        // his linked list of a specific node type into the parent type, Node. But, that's kind of messy
        // this is cleaner for the user, but messier for the code in this method.
        LinkedList<Node> childNodes_casted = (LinkedList<Node>) childNodes;

        CodeBuilder codeBuilder = new CodeBuilder();

        for (Node childNode: childNodes_casted) {

            if (childNode != null) {
                if (addBeforeTextString != null) codeBuilder.append(addBeforeTextString);
                codeBuilder.append(childNode.code());
                if (appendTextString != null) codeBuilder.append(appendTextString);
            }
        }

        return codeBuilder;

    }





}


